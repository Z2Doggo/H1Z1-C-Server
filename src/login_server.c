// TODO(rhett): custom preprocessor?

#include <ctype.h>
#include <stdio.h>
#include <time.h>

#define YOTE_USE_ARENA   1
#define YOTE_USE_ENDIAN  1
#define YOTE_USE_STRING  1
#include "yote.h"
#define YOTE_PLATFORM_USE_SOCKETS  1
#include "yote_platform.h"

#include "game_server.h"

#define LOCAL_PORT          20042
#define MAX_SESSIONS_COUNT  16

#include "utility/util.c"
#include "utility/crypt_rc4.c"
#include "session.h"


struct App_State
{
	Platform_Api* platform_api;
	Platform_Socket socket;

	Arena arena_total;
	Arena arena_per_tick;

	i32 rc4_key_decoded_length;
	u8 rc4_key_decoded[256];

	Session_Pool session_pool;

	// TEMPORARY(rhett): 
	Stream fragment_accumulator;
};

global u64 global_tick_count;
global u64 global_dump_count;
global b32 global_should_dump_core = TRUE;
#define PACKET_FOLDER  "..\\LOGIN_PACKETS"


#undef MESSAGE_NAMESPACE
#define MESSAGE_NAMESPACE  "Core"
#include "core_protocol.c"
#undef MESSAGE_NAMESPACE
#define MESSAGE_NAMESPACE  "Login"
#define printf(...)
#include "../schema/output/login_udp_11.c"
#undef printf
#include "login//login_udp_11.c"
#undef MESSAGE_NAMESPACE
#define MESSAGE_NAMESPACE MESSAGE_NAMESPACE_DEFAULT


CORE_DATA_INPUT_CALLBACK(on_core_data_input)
{
	protocol_login_packet_route(data_buffer, session_handle, app_state);
}

SESSION_ESTABLISHED_CALLBACK(on_session_established)
{
	Session_State* session = session_get_pointer_from_handle(&app_state->session_pool, session_handle);
	session->protocol_options.use_encryption = TRUE;
}

__declspec(dllexport) APP_TICK(server_tick)
{
	global_tick_count = app_memory->tick_count;
	App_State* app_state = app_memory->app_state;
	if (!app_state)
	{
		app_state = app_memory->app_state = arena_bootstrap_push_struct(app_memory->backing_memory.data,
		                                                                app_memory->backing_memory.size,
		                                                                "Total",
		                                                                App_State,
		                                                                arena_total);
		app_state->platform_api = &app_memory->platform_api;

		app_state->arena_per_tick =
			(Arena) {
			.capacity = MB(10),
			.buffer = arena_push_size(&app_state->arena_total, MB(10)),
			.name = "Tick",
		};

		u8 rc4_key_encoded[] = "F70IaxuU8C/w7FPXY1ibXw==";
		app_state->rc4_key_decoded_length = util_base64_decode(cast(u8*)rc4_key_encoded,
		                                                       SIZE_OF(rc4_key_encoded) - 1,
		                                                       app_state->rc4_key_decoded);

		app_state->session_pool = session_pool_create(&app_state->arena_total, MAX_SESSIONS_COUNT);
		app_state->fragment_accumulator =
			(Stream) {
			.size = MB(1),
			.data = arena_push_size(&app_state->arena_total, MB(1)),
		};

		app_state->socket = app_state->platform_api->socket_udp_create_and_bind(LOCAL_PORT);
		printf(MESSAGE_CONCAT_INFO("Login server socket bound to port " STRINGIFY(LOCAL_PORT) "\n\n"));
	}

#if 0
	//------------------------------------------------------------
	//-----------       Created with 010 Editor        -----------
	//------         www.sweetscape.com/010editor/          ------
	//
	// File    : D:\Projects\ps2_server_emulator\build_login_server\packets\288_2_C_core_DataFragment.bin
	// Address : 0 (0x0)
	// Size    : 512 (0x200)
	//------------------------------------------------------------
	unsigned char hexData[512] = {
		0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x07, 0x7E, 0xAA, 0xB7, 0xB8, 0x43, 0xF1, 0x70, 0xD5, 0x03,
		0x8C, 0x13, 0x1F, 0x04, 0x1F, 0xBF, 0xDC, 0x7F, 0x3E, 0x5E, 0xBD, 0xD9, 0x4E, 0x11, 0xCD, 0x89,
		0xFD, 0xA4, 0x64, 0xDD, 0xCC, 0xBB, 0xA3, 0x80, 0x47, 0xCD, 0xC4, 0x8D, 0x08, 0x67, 0x30, 0xBA,
		0x57, 0xF3, 0xD7, 0xF6, 0xE2, 0x41, 0xEB, 0xB3, 0x7C, 0x92, 0x1B, 0x82, 0x12, 0x3E, 0xFE, 0x59,
		0x63, 0xC4, 0x70, 0x2A, 0x01, 0xC1, 0xC0, 0x5A, 0x68, 0x20, 0x1F, 0x76, 0x39, 0x8C, 0x67, 0x17,
		0x59, 0xD7, 0x42, 0xC3, 0x0A, 0xF7, 0x8F, 0xCB, 0x48, 0x81, 0xCA, 0xA9, 0x5E, 0xF0, 0x94, 0x9E,
		0x4A, 0x4D, 0xCB, 0x5E, 0x4E, 0x8F, 0xD9, 0x23, 0x05, 0xA5, 0x08, 0x43, 0x23, 0x01, 0xB8, 0xC2,
		0xA4, 0x64, 0x55, 0x1B, 0x2E, 0x52, 0xB2, 0xFA, 0x04, 0x06, 0x72, 0xFB, 0x75, 0xFC, 0x03, 0x12,
		0xBB, 0xB7, 0xEA, 0x4C, 0xD8, 0xD3, 0x6C, 0xDF, 0x1D, 0x18, 0x8E, 0xC7, 0xEB, 0x5E, 0x65, 0x97,
		0xBE, 0xA0, 0x32, 0xF9, 0xBC, 0x0D, 0xB7, 0x0B, 0x52, 0xE6, 0x8B, 0x16, 0x31, 0x05, 0x5E, 0x85,
		0x4C, 0x46, 0x38, 0x96, 0x5F, 0xF5, 0x1C, 0x50, 0xF5, 0x02, 0x41, 0x46, 0x03, 0x43, 0xD1, 0x99,
		0xAF, 0xAC, 0x68, 0x16, 0x04, 0x23, 0xED, 0xB2, 0xEE, 0x06, 0x26, 0x01, 0xB6, 0xD0, 0x02, 0x3A,
		0x43, 0xF4, 0x5D, 0x1D, 0x03, 0x18, 0x82, 0x0C, 0x52, 0x11, 0xD1, 0xF0, 0xE2, 0x1E, 0xD0, 0x76,
		0x45, 0x47, 0xEF, 0xB1, 0x1F, 0x62, 0x34, 0xE0, 0x62, 0x94, 0x46, 0x82, 0xD3, 0x93, 0xF4, 0xAC,
		0x17, 0x7C, 0x37, 0x8B, 0xC6, 0xCD, 0xFD, 0xDB, 0xDA, 0x53, 0x1D, 0xD0, 0x78, 0xA5, 0x1F, 0xC2,
		0x2F, 0x7D, 0x60, 0x61, 0x00, 0xD1, 0xA7, 0x24, 0x17, 0x1A, 0x55, 0xE2, 0x22, 0x81, 0xD7, 0xAE,
		0xB6, 0x3F, 0x4C, 0xB0, 0xFD, 0xB9, 0x8C, 0x26, 0x42, 0x35, 0x8F, 0x70, 0x5B, 0x5D, 0xF4, 0xD1,
		0xC9, 0x29, 0xA6, 0xE7, 0x41, 0xCD, 0x39, 0xB3, 0x4A, 0x7E, 0xBE, 0x6F, 0x89, 0x30, 0xF7, 0x87,
		0x91, 0xAD, 0xC5, 0x28, 0x9B, 0xD6, 0xC4, 0xE2, 0xF7, 0x7B, 0xE6, 0xD3, 0x55, 0xAE, 0xCD, 0x92,
		0xA4, 0xAE, 0xF7, 0x32, 0x70, 0x7D, 0x4E, 0x6C, 0x09, 0x0F, 0xC4, 0x1E, 0xB5, 0x38, 0x91, 0x15,
		0x2A, 0x94, 0x28, 0x13, 0x39, 0xB9, 0xF6, 0x6E, 0xA0, 0x14, 0xCA, 0x1B, 0x0E, 0xF7, 0x85, 0xCF,
		0x76, 0x60, 0xD7, 0x97, 0x0C, 0x54, 0x2A, 0x9E, 0x83, 0x92, 0x23, 0x0F, 0xD9, 0xF4, 0x40, 0xFD,
		0x85, 0xB2, 0x80, 0xFD, 0x41, 0x1E, 0x40, 0x5D, 0x0F, 0x9A, 0x0E, 0x30, 0xE6, 0xE9, 0x66, 0x4B,
		0xAE, 0x95, 0x91, 0x36, 0xB4, 0xDA, 0x48, 0x11, 0xD4, 0x5D, 0x50, 0xFD, 0x78, 0x91, 0x0C, 0xBF,
		0x88, 0xD0, 0x0A, 0x9A, 0x1F, 0xD8, 0x60, 0x5C, 0x05, 0x36, 0xB0, 0xCB, 0x66, 0xD7, 0xE8, 0xCC,
		0xAB, 0xB4, 0x06, 0x5A, 0x03, 0xF7, 0xA8, 0xE9, 0xDA, 0xFC, 0x5E, 0x98, 0xC6, 0x2B, 0x22, 0x32,
		0x0D, 0x69, 0xF5, 0x5C, 0x5F, 0xFA, 0x6F, 0x51, 0x8E, 0x2D, 0x91, 0x90, 0x6C, 0x93, 0x23, 0xD8,
		0x0E, 0xD5, 0x46, 0x43, 0x4A, 0xE7, 0x20, 0xE1, 0x5C, 0xBF, 0xA1, 0xFF, 0xC0, 0xBB, 0x13, 0x8E,
		0x6B, 0x49, 0xAF, 0x0C, 0xE5, 0xB5, 0xF3, 0xC4, 0x58, 0x79, 0x86, 0xC7, 0x25, 0xE9, 0xC4, 0xC0,
		0xC6, 0x82, 0x1E, 0x79, 0xC5, 0x93, 0x51, 0xDA, 0x06, 0xC5, 0x39, 0x5D, 0xF5, 0x4A, 0x47, 0xEA,
		0xED, 0x08, 0x10, 0x30, 0xE5, 0x24, 0xA0, 0xAF, 0xD4, 0x79, 0x09, 0xA7, 0x75, 0x84, 0xD4, 0x50,
		0x8B, 0xEF, 0xAA, 0xB5, 0xBA, 0x60, 0xF2, 0x7A, 0x84, 0xAE, 0x96, 0x5E, 0x13, 0x21, 0x86, 0x0D 
	};

	//------------------------------------------------------------
	//-----------       Created with 010 Editor        -----------
	//------         www.sweetscape.com/010editor/          ------
	//
	// File    : D:\Projects\ps2_server_emulator\build_login_server\packets\289_4_C_core_DataFragment.bin
	// Address : 0 (0x0)
	// Size    : 512 (0x200)
	//------------------------------------------------------------
	unsigned char hexData2[512] = {
		0x00, 0x0D, 0x00, 0x01, 0xE2, 0xA5, 0x0A, 0x08, 0x90, 0x4E, 0x1E, 0x5E, 0x60, 0x79, 0x3E, 0x05,
		0xB9, 0x19, 0xE1, 0xEF, 0x42, 0x7E, 0x36, 0x49, 0x1D, 0xA1, 0x08, 0x6C, 0x6A, 0x89, 0x65, 0xCC,
		0xB2, 0x23, 0x09, 0x3F, 0x31, 0xB7, 0x99, 0x19, 0x6E, 0x87, 0x6A, 0xC2, 0x80, 0x28, 0xEB, 0x3F,
		0x1A, 0xA8, 0xFB, 0x7A, 0xD3, 0x90, 0x69, 0xC2, 0x0D, 0x46, 0x8D, 0xE1, 0xF5, 0xE5, 0xC5, 0x57,
		0x8C, 0xB6, 0xD7, 0x6A, 0x5B, 0x83, 0x61, 0x28, 0x1F, 0xFD, 0x11, 0x78, 0x68, 0x49, 0xB7, 0x5A,
		0xF1, 0x9E, 0x5E, 0xA2, 0xD2, 0xAA, 0x6D, 0xCC, 0x0A, 0x81, 0x5E, 0xC7, 0x59, 0x8A, 0x84, 0x55,
		0x34, 0xD3, 0x09, 0xDB, 0x54, 0xD1, 0x4A, 0x57, 0xA0, 0x7E, 0x20, 0x89, 0x37, 0x24, 0xAA, 0xE6,
		0x64, 0xD3, 0xB9, 0x17, 0x3A, 0x44, 0xC9, 0x82, 0x2E, 0xF8, 0x2D, 0x91, 0xBE, 0x9C, 0xAC, 0xA9,
		0xB7, 0x16, 0x7F, 0x3C, 0xEB, 0x14, 0xDF, 0x97, 0x28, 0xA8, 0x02, 0x87, 0x29, 0x0B, 0x9F, 0x34,
		0xB2, 0x7E, 0x6F, 0x78, 0x18, 0xC6, 0x12, 0x4C, 0x9C, 0x40, 0x3B, 0xC5, 0x83, 0x54, 0x84, 0x38,
		0xDC, 0x81, 0x07, 0x1C, 0x3F, 0x00, 0xCB, 0x82, 0x42, 0xC3, 0xCA, 0x8D, 0x09, 0x7F, 0x9B, 0xDF,
		0x77, 0xCE, 0x9C, 0xA1, 0xC1, 0x48, 0x8F, 0x27, 0xC5, 0xCE, 0x41, 0x45, 0xF4, 0x9C, 0x15, 0x8E,
		0x64, 0x6F, 0xBF, 0xBC, 0x9C, 0xEC, 0x35, 0x81, 0xB3, 0x9B, 0x86, 0x31, 0x90, 0xA7, 0xD0, 0xBA,
		0xD2, 0x9E, 0x3C, 0x5A, 0x69, 0x54, 0xFB, 0x65, 0x3B, 0xF8, 0x00, 0x23, 0x64, 0x94, 0xEE, 0xE5,
		0xF2, 0x06, 0x02, 0x8B, 0xCF, 0xBF, 0x8A, 0x04, 0xAB, 0x53, 0x47, 0x79, 0x8E, 0x87, 0x4F, 0x59,
		0xE6, 0xFB, 0xB2, 0xCE, 0xC3, 0x1E, 0x82, 0xF9, 0xA6, 0x32, 0xA5, 0xC5, 0x91, 0x0D, 0x0E, 0x29,
		0x5E, 0xB2, 0xDD, 0x68, 0x61, 0x1F, 0x2F, 0xED, 0x7C, 0x14, 0x38, 0x8D, 0x2B, 0x6F, 0x01, 0x9F,
		0xFA, 0x7F, 0x2B, 0xAE, 0xC6, 0x17, 0xD9, 0xCB, 0x18, 0x94, 0x3D, 0xF7, 0xA6, 0xD4, 0x8F, 0x87,
		0x16, 0xE0, 0x83, 0x64, 0xBE, 0x35, 0x98, 0xB0, 0x58, 0x3F, 0x96, 0x1A, 0x8F, 0xCB, 0xDA, 0xAD,
		0xB2, 0x0F, 0xE0, 0xC3, 0x3E, 0x23, 0xEB, 0x5E, 0x8C, 0x05, 0xD9, 0x7E, 0xAB, 0x1F, 0x32, 0xA6,
		0xE2, 0xFF, 0x37, 0xF1, 0x6D, 0x6C, 0x4A, 0x06, 0x2C, 0xA9, 0x7F, 0x3A, 0xFA, 0xE6, 0xED, 0x1C,
		0xD8, 0xB2, 0x63, 0x68, 0x87, 0x92, 0xCE, 0xD1, 0x0A, 0xF2, 0x20, 0xEE, 0x5D, 0x12, 0x31, 0x8F,
		0x98, 0x28, 0xCF, 0xCE, 0xC3, 0xB2, 0x8F, 0x63, 0x39, 0xC8, 0x86, 0xC6, 0xAA, 0xFE, 0xA3, 0xC9,
		0xBE, 0x1D, 0xB6, 0x18, 0x7B, 0x4E, 0x2F, 0x67, 0xA7, 0x05, 0x4B, 0x54, 0x01, 0x3D, 0x8F, 0x64,
		0x56, 0xE5, 0xFB, 0x05, 0xE4, 0x02, 0x4E, 0xA6, 0x72, 0x17, 0xDD, 0xD3, 0x3B, 0xD4, 0xDE, 0xB8,
		0xD0, 0x16, 0x04, 0x6A, 0x4C, 0xF6, 0x0D, 0xD4, 0xBE, 0xD2, 0xED, 0xAA, 0x8D, 0xF8, 0x8D, 0x4F,
		0x5C, 0xBD, 0xF6, 0x0F, 0x59, 0x7C, 0x81, 0x74, 0x50, 0x20, 0x10, 0x68, 0xF8, 0xE4, 0x9F, 0x72,
		0x94, 0xF0, 0x2B, 0x66, 0x06, 0x03, 0xC7, 0x6F, 0xEB, 0x98, 0x71, 0xEB, 0x8C, 0x36, 0x07, 0x61,
		0x89, 0x7B, 0xDD, 0x89, 0xB2, 0x7A, 0x48, 0x78, 0xF0, 0x13, 0x90, 0xDB, 0x6E, 0xD3, 0x0C, 0xE6,
		0x69, 0xF0, 0xCD, 0x98, 0x3B, 0xC0, 0x95, 0x73, 0x32, 0x70, 0x8B, 0xB2, 0x4D, 0x33, 0x9B, 0xD6,
		0x41, 0xE9, 0xF5, 0xF1, 0x59, 0x80, 0x10, 0xEA, 0xA9, 0x1F, 0x5C, 0x1B, 0xC7, 0x3B, 0x1A, 0x9A,
		0x7A, 0x7B, 0xE0, 0x81, 0x6D, 0x2B, 0x83, 0x57, 0x4B, 0x4B, 0xF1, 0x2D, 0xDF, 0x79, 0x4E, 0x50 
	};

	//------------------------------------------------------------
	//-----------       Created with 010 Editor        -----------
	//------         www.sweetscape.com/010editor/          ------
	//
	// File    : D:\Projects\ps2_server_emulator\build_login_server\packets\290_6_C_core_DataFragment.bin
	// Address : 0 (0x0)
	// Size    : 512 (0x200)
	//------------------------------------------------------------
	unsigned char hexData3[512] = {
		0x00, 0x0D, 0x00, 0x02, 0x54, 0x23, 0xC2, 0xEF, 0xB3, 0xDD, 0xB6, 0xE0, 0xBF, 0x72, 0x08, 0x39,
		0xE2, 0x55, 0x09, 0x02, 0xC3, 0x29, 0x03, 0x5D, 0x82, 0x6B, 0x57, 0x4C, 0x43, 0x72, 0x73, 0x4B,
		0x32, 0xB0, 0x91, 0x0E, 0x30, 0xA9, 0x84, 0x15, 0x31, 0x8A, 0x3E, 0xE4, 0xB3, 0x54, 0x70, 0x3D,
		0x86, 0xF1, 0xFB, 0x96, 0x57, 0xBE, 0xC8, 0x64, 0xB6, 0x96, 0x12, 0x60, 0x91, 0x85, 0x31, 0x0B,
		0x4E, 0xE3, 0xF2, 0xEF, 0xB7, 0x0B, 0x2F, 0x68, 0x84, 0x68, 0x50, 0xD6, 0x25, 0xAD, 0x87, 0x0A,
		0xF8, 0x8C, 0x98, 0x6D, 0xF5, 0xED, 0x58, 0x2D, 0xCB, 0xE5, 0xEF, 0xF3, 0xE8, 0x46, 0x13, 0x0F,
		0x35, 0x2B, 0x33, 0x27, 0x7A, 0x09, 0x20, 0xDE, 0x9C, 0x97, 0xAE, 0x75, 0xFD, 0xAF, 0x84, 0x74,
		0xE2, 0x48, 0x64, 0xFD, 0x61, 0x61, 0x62, 0x77, 0xE1, 0x25, 0xBC, 0xD9, 0x65, 0xD8, 0xD2, 0x2C,
		0xBF, 0xBB, 0x22, 0x56, 0x6E, 0xC1, 0xF9, 0xDE, 0x23, 0x65, 0xC0, 0xB7, 0xFB, 0xF0, 0x24, 0xA7,
		0xC6, 0x20, 0x97, 0x71, 0x66, 0x39, 0x9E, 0x5F, 0x9A, 0x6E, 0x5D, 0xDF, 0x96, 0xF9, 0xB9, 0xA7,
		0x3E, 0xE4, 0x00, 0x49, 0x89, 0x91, 0x97, 0xCB, 0x31, 0x24, 0x2D, 0x3A, 0x1A, 0xDF, 0x04, 0x00,
		0x3A, 0xA3, 0x94, 0x8C, 0x3C, 0x40, 0x1D, 0x37, 0x08, 0x9B, 0x4E, 0xF1, 0xC6, 0x00, 0xA0, 0x0F,
		0x5B, 0x21, 0xA0, 0xAC, 0x58, 0xE0, 0x2F, 0x2E, 0x0C, 0xCE, 0xC6, 0x10, 0x6A, 0x75, 0x75, 0x05,
		0x1C, 0x29, 0x82, 0xCB, 0x00, 0x57, 0xA6, 0x00, 0x6D, 0x9C, 0xAF, 0x32, 0x1E, 0x7A, 0xB2, 0xE7,
		0x54, 0xDE, 0xF4, 0x0F, 0x7B, 0x99, 0xFC, 0x35, 0xDF, 0x85, 0xEB, 0xB6, 0x36, 0x85, 0xAE, 0xC0,
		0x3C, 0x77, 0x4B, 0x4C, 0x67, 0x33, 0x4F, 0xE0, 0x11, 0x2B, 0x55, 0xE2, 0x63, 0xC2, 0x6E, 0xCF,
		0x39, 0x40, 0xFA, 0x47, 0x26, 0x7F, 0x0A, 0x94, 0xFA, 0x0E, 0x13, 0xF2, 0x0C, 0x6B, 0xAC, 0x31,
		0x13, 0xE0, 0x5D, 0x81, 0x48, 0x18, 0x1A, 0x53, 0xCD, 0x09, 0x78, 0xC8, 0xD4, 0x82, 0x25, 0x56,
		0x1F, 0x11, 0xBA, 0x49, 0xDA, 0xAD, 0xB5, 0xB1, 0x3E, 0xE9, 0x44, 0x43, 0x8B, 0xBB, 0x3A, 0x4D,
		0xA0, 0xC6, 0xE0, 0x3F, 0x78, 0x10, 0x4C, 0x93, 0xBB, 0xE1, 0xCE, 0x6C, 0x1A, 0xAD, 0x57, 0xD8,
		0x64, 0xE2, 0xDA, 0x1F, 0xE2, 0x17, 0xC2, 0xC2, 0x62, 0xDD, 0xAC, 0xAC, 0xC6, 0xC3, 0xFB, 0x95,
		0xFC, 0x2D, 0x21, 0xDA, 0x6D, 0x3C, 0x66, 0x06, 0x99, 0x27, 0xBC, 0x76, 0xFF, 0xF7, 0x5B, 0x57,
		0xAB, 0x40, 0x20, 0x0B, 0x74, 0x03, 0x95, 0x81, 0x49, 0x7D, 0xA3, 0x36, 0xFB, 0xC9, 0x4E, 0xCB,
		0x16, 0xFB, 0x41, 0x7B, 0xC6, 0xE5, 0x22, 0x1E, 0xEF, 0x12, 0x46, 0xE6, 0xF8, 0xFE, 0x7C, 0xA3,
		0x51, 0xCF, 0x46, 0xC7, 0x01, 0x5F, 0xD8, 0x60, 0x36, 0xDA, 0xE6, 0xA0, 0x52, 0xCF, 0x56, 0xE2,
		0x49, 0x89, 0x65, 0x97, 0x6A, 0x4B, 0x63, 0x51, 0xAB, 0xB9, 0x79, 0xC3, 0x83, 0xD9, 0x29, 0xC9,
		0x07, 0xA1, 0x50, 0xEB, 0xC6, 0xB4, 0x47, 0xD3, 0xDA, 0x96, 0xD1, 0x37, 0xDE, 0x9F, 0x82, 0xD6,
		0x37, 0x8A, 0xA9, 0x33, 0x54, 0xD0, 0xF6, 0x3D, 0x23, 0xA1, 0x31, 0x85, 0x0C, 0x93, 0x28, 0xE7,
		0xE9, 0x30, 0x46, 0x60, 0x66, 0xA9, 0xCF, 0x4A, 0x1B, 0xD6, 0x16, 0xCA, 0x7D, 0x20, 0x42, 0x73,
		0x63, 0x34, 0x10, 0x22, 0x81, 0x59, 0x2D, 0xF5, 0x51, 0xE9, 0x5D, 0xD6, 0x79, 0xDF, 0xF8, 0x48,
		0xAB, 0xBE, 0x01, 0x68, 0x87, 0xDD, 0xA1, 0x00, 0x61, 0x69, 0xC9, 0x23, 0x12, 0x49, 0x84, 0x03,
		0x51, 0x01, 0x1F, 0x56, 0xE9, 0xCE, 0x49, 0x4B, 0xDC, 0xEE, 0xC8, 0x22, 0xEA, 0xEA, 0x28, 0x9C 
	};

	//------------------------------------------------------------
	//-----------       Created with 010 Editor        -----------
	//------         www.sweetscape.com/010editor/          ------
	//
	// File    : D:\Projects\ps2_server_emulator\build_login_server\packets\291_8_C_core_DataFragment.bin
	// Address : 0 (0x0)
	// Size    : 402 (0x192)
	//------------------------------------------------------------
	unsigned char hexData4[402] = {
		0x00, 0x0D, 0x00, 0x03, 0x26, 0x8C, 0xD3, 0xC6, 0xA5, 0xBA, 0x6C, 0xA9, 0x57, 0x0E, 0x0A, 0xBD,
		0xD2, 0xEA, 0x77, 0x74, 0x61, 0x8D, 0xAF, 0xFE, 0xB7, 0x36, 0x28, 0xCB, 0x72, 0x5F, 0xE3, 0x1F,
		0xC9, 0xCD, 0xCE, 0x65, 0xDD, 0xEC, 0xF2, 0x45, 0xC5, 0x56, 0xBC, 0x4C, 0x9B, 0x5C, 0x5E, 0xF5,
		0xAA, 0x85, 0xC7, 0xF5, 0xDB, 0xFB, 0xEE, 0x2A, 0x60, 0x74, 0xA1, 0x2B, 0xFE, 0x52, 0x62, 0x75,
		0xF8, 0x2B, 0x4E, 0x1D, 0x4F, 0x37, 0x67, 0x36, 0xC6, 0x69, 0x3F, 0xF0, 0x67, 0xF5, 0xFE, 0x63,
		0x4D, 0x72, 0x56, 0xFD, 0x5E, 0x98, 0x11, 0xFC, 0x95, 0x72, 0x88, 0x15, 0x0C, 0x95, 0x91, 0x45,
		0xD1, 0x58, 0xFA, 0x12, 0xD7, 0x0B, 0x4E, 0xC1, 0xF2, 0xD1, 0x39, 0xB6, 0x47, 0xA1, 0xE6, 0xBB,
		0x69, 0xDE, 0x27, 0x5B, 0x8C, 0xA3, 0xE6, 0x5D, 0xBA, 0xA6, 0x84, 0x1E, 0x4D, 0x9B, 0x0E, 0x71,
		0x23, 0x76, 0x15, 0x80, 0xFB, 0xDC, 0xCF, 0x1E, 0x58, 0xA3, 0x15, 0x39, 0x4C, 0x26, 0xD3, 0xB4,
		0xC5, 0xA6, 0x17, 0x2F, 0x8C, 0x0A, 0x21, 0x8A, 0xDE, 0xD1, 0x41, 0xD3, 0x31, 0xDF, 0x18, 0xF6,
		0xD2, 0x48, 0x0F, 0x47, 0x53, 0xFB, 0xE2, 0xFF, 0x44, 0xCB, 0x05, 0xFD, 0x4B, 0xF7, 0xB9, 0x1A,
		0x7C, 0x90, 0x20, 0xA7, 0x78, 0x8D, 0xA7, 0x9A, 0xB4, 0xF6, 0xBB, 0x99, 0xF6, 0xCC, 0xF8, 0xCF,
		0x71, 0x9C, 0x19, 0x38, 0xDC, 0x34, 0xE8, 0x86, 0x21, 0x1D, 0xF3, 0x74, 0x7A, 0xCE, 0x5F, 0xF7,
		0x94, 0xA5, 0xC6, 0xA8, 0x36, 0x0D, 0xA0, 0x10, 0xED, 0xCF, 0x76, 0x7C, 0x52, 0x46, 0x39, 0x23,
		0xEC, 0xC6, 0xD4, 0x86, 0x33, 0x12, 0x04, 0xB3, 0xAF, 0x44, 0x84, 0x30, 0x38, 0xBC, 0x2B, 0x2A,
		0x34, 0x1B, 0xF8, 0x9B, 0xDA, 0x97, 0x50, 0x7D, 0x6B, 0x9C, 0x41, 0xAF, 0xB6, 0x3C, 0x94, 0x06,
		0x57, 0x48, 0x5B, 0x58, 0x22, 0xD3, 0xC4, 0x66, 0xD6, 0xCF, 0xEC, 0xCB, 0x9A, 0x68, 0x25, 0x0A,
		0xA1, 0x4E, 0x1A, 0x45, 0x47, 0x44, 0x68, 0xB4, 0x69, 0x0B, 0x62, 0xA3, 0xEC, 0x56, 0x03, 0xE4,
		0x0A, 0xBA, 0x11, 0x04, 0xBB, 0xA4, 0x45, 0x30, 0xFA, 0x23, 0xDF, 0x01, 0x5F, 0x00, 0xE1, 0x6E,
		0x19, 0x9E, 0x62, 0x06, 0x29, 0xB4, 0x95, 0xE1, 0x95, 0x29, 0x7C, 0xCB, 0xD1, 0x0B, 0xB9, 0x5E,
		0xCF, 0xBD, 0x2A, 0xB7, 0x1B, 0x69, 0xAC, 0xBE, 0x7F, 0xCC, 0xBB, 0xD3, 0x8A, 0x08, 0xAA, 0x84,
		0xA5, 0x6A, 0xD1, 0x93, 0xFC, 0x7B, 0xDD, 0x51, 0x2D, 0x61, 0xBE, 0x85, 0x64, 0x05, 0x51, 0x26,
		0x92, 0x9A, 0xB9, 0x98, 0x8E, 0xED, 0x70, 0x35, 0x9D, 0x0D, 0x58, 0xDE, 0xDA, 0xC6, 0x71, 0xD6,
		0xAA, 0x41, 0x75, 0xF9, 0x09, 0x19, 0xFC, 0xE4, 0x9A, 0x61, 0x9D, 0x99, 0x64, 0x29, 0x45, 0xBC,
		0xB8, 0xC1, 0x8C, 0x3F, 0x48, 0x16, 0x42, 0xAC, 0xCA, 0x91, 0x7E, 0x26, 0x52, 0xAE, 0x55, 0xA4,
		0xDC, 0x76 
	};

	Buffer buffer = { .size = SIZE_OF(hexData), .data = hexData };
	Buffer buffer2 = { .size = SIZE_OF(hexData2), .data = hexData2 };
	Buffer buffer3 = { .size = SIZE_OF(hexData3), .data = hexData3 };
	Buffer buffer4 = { .size = SIZE_OF(hexData4), .data = hexData4 };

	{Session_State* session = 0;
	Session_Handle session_handle = session_get_handle_from_address(&app_state->session_pool, (Session_Address) { 1 });
	if (!session_handle.id)
	{
		session_handle = session_acquire(&app_state->session_pool, (Session_Address) { 1 });
		if (!session_handle.id)
		{
			NOT_IMPLEMENTED_MSG("No more free session slots");
		}

		session = session_get_pointer_from_handle(&app_state->session_pool, session_handle);

		// NOTE(rhett): address and handle already filled out
		session->protocol_options =
			(Protocol_Options) {
			.crc_seed = 0,
			.crc_size = 0,
			.compression = 0,
			.udp_size = MAX_PACKET_SIZE,
			.use_encryption = FALSE,
		};
		session->acked_in = -1;
		session->sequence_in = -1;
		session->sequence_out = -1;
		crypt_rc4_initialize(&session->rc4_state_in, app_state->rc4_key_decoded, app_state->rc4_key_decoded_length);
		crypt_rc4_initialize(&session->rc4_state_out, app_state->rc4_key_decoded, app_state->rc4_key_decoded_length);
	}

	protocol_core_packet_route(buffer, FALSE, session_handle, app_state);
	protocol_core_packet_route(buffer2, FALSE, session_handle, app_state);
	protocol_core_packet_route(buffer3, FALSE, session_handle, app_state);
	protocol_core_packet_route(buffer4, FALSE, session_handle, app_state);}
#endif

	DEFER_SCOPE(0, arena_reset(&app_state->arena_per_tick))
	{
		u8 incoming_buffer[MAX_PACKET_SIZE] = { 0 };
		u32 from_ip;
		u16 from_port;
		i32 receive_result = app_state->platform_api->receive_from(app_state->socket,
		                                                           incoming_buffer,
		                                                           MAX_PACKET_SIZE,
		                                                           &from_ip,
		                                                           &from_port);
		ASSERT(receive_result <= SIZE_OF(incoming_buffer));
		
		if (receive_result)
		{
			printf("\n\n________________________________________ Packet Tick Begin _________________________________________\n");

			Session_Address incoming_session_address =
			{
				.ip = from_ip,
				.port = from_port,
			};

			Session_State* session = 0;
			Session_Handle session_handle = session_get_handle_from_address(&app_state->session_pool, incoming_session_address);
			if (!session_handle.id)
			{
				session_handle = session_acquire(&app_state->session_pool, incoming_session_address);
				if (!session_handle.id)
				{
					NOT_IMPLEMENTED_MSG("No more free session slots");
				}

				session = session_get_pointer_from_handle(&app_state->session_pool, session_handle);

				// NOTE(rhett): address and handle already filled out
				session->protocol_options =
					(Protocol_Options) {
					.crc_seed = 0,
					.crc_size = 0,
					.compression = 0,
					.udp_size = MAX_PACKET_SIZE,
					.use_encryption = FALSE,
				};
				session->acked_in = -1;
				session->sequence_in = -1;
				session->sequence_out = -1;
				crypt_rc4_initialize(&session->rc4_state_in, app_state->rc4_key_decoded, app_state->rc4_key_decoded_length);
				crypt_rc4_initialize(&session->rc4_state_out, app_state->rc4_key_decoded, app_state->rc4_key_decoded_length);
			}

			// NOTE(rhett): session pointer wasn't already received during session init
			if (!session)
			{
				session = session_get_pointer_from_handle(&app_state->session_pool, session_handle);
				ASSERT(session);
			}

			if (!session->handle.id)
			{
				NOT_IMPLEMENTED_MSG("we got the invalid session, something went wrong");
			}

			Buffer packet_buffer =
			{
				.size = receive_result,
				.data = cast(u8*)&incoming_buffer
			};

			if (session->kind == Session_Kind_Ping_Responder)
			{
				NOT_IMPLEMENTED_MSG("Handle ping responder");
			}
			else
			{
				protocol_core_packet_route(packet_buffer, FALSE, session_handle, app_state);
			}

			if (session->sequence_in > session->acked_in)
			{
				for (i32 ack_iter = 0; ack_iter < (session->sequence_in - session->acked_in); ack_iter++)
				{
					// NOTE(rhett): starts at -1
					session->acked_in++;
					Core_Packet_Ack ack =
					{
						.sequence = cast(u16)session->acked_in,
					};
					protocol_core_packet_send(&ack, Core_Packet_Kind_Ack, session_handle, app_state);
				}
			}

			printf("----------------------------------------- Packet Tick End ------------------------------------------\n");
		}
	}
}



#if 0
#if defined(YOTE_INTERNAL)
#include <stdio.h>
#else
static void platform_win_console_write(char* format, ...);
#define printf(s, ...) platform_win_console_write(s, __VA_ARGS__)
#endif // YOTE_INTERNAL

#define YOTE_USE_ARENA   1
#define YOTE_USE_STRING  1
#include "yote.h"
#define YOTE_PLATFORM_USE_SOCKETS  1
#include "yote_platform.h"
#include "game_server.h"

#define LOCAL_PORT          20042
#define MAX_FRAGMENTS       12000
#define MAX_PACKET_LENGTH   512
#define DATA_HEADER_LENGTH  4
#define MAX_SESSIONS_COUNT  2

#include "utility/endian.c"
#include "utility/util.c"
#include "utility/crypt_rc4.c"
#include "shared/protocol/stream.h"
#include "shared/protocol/fragment_pool.c"
#include "shared/protocol/input_stream.c"
#include "shared/protocol/output_stream.c"
#include "shared/protocol/core_protocol.h"
#include "shared/connection.h"
#include "shared/session.h"
#include "shared/packet_queue.h"
#include "shared/packet_queue.c"

global u64 global_packet_dump_count;
// HACK(rhett):
global u64 global_tick_count;

typedef struct Stream_Function_Table Stream_Function_Table;
struct Stream_Function_Table
{
	input_stream_callback_ack*    login_input_ack;
	input_stream_callback_data*   login_input_data;
	output_stream_callback_data*  login_output_data;
	input_stream_callback_data*   ping_input_data;
};

struct App_State
{
	Stream_Function_Table* stream_function_table;
	f32* tick_ms;
	f32* work_ms;
	u64* tick_count;
	Key_States* key_states;

#if defined(TERMINAL_UI)
	Buffer screen;
#endif // TERMINAL_UI

	Arena arena_total;
	Platform_Api* platform_api;
	Arena arena_per_tick;

	Platform_Socket socket;

	u8 rc4_key_decoded[256];
	i32 rc4_key_decoded_length;
	Connection_Args connection_args;

	i32 sessions_capacity;
	Session_State sessions[MAX_SESSIONS_COUNT];
};

internal INPUT_STREAM_CALLBACK_DATA(on_ping_input_stream_data);

#undef MESSAGE_NAMESPACE
#define MESSAGE_NAMESPACE  "Core"
#include "shared/protocol/core_protocol.c"
#undef MESSAGE_NAMESPACE
#define MESSAGE_NAMESPACE  "Login"
#include "../schema/output/login_udp_2_july.c"
#include "login/login_udp_2_july.c"
#undef MESSAGE_NAMESPACE
#define MESSAGE_NAMESPACE  MESSAGE_NAMESPACE_DEFAULT


internal INPUT_STREAM_CALLBACK_ACK(on_input_stream_ack)
{
	Session_State* session_state = session;
	session_state->ack_next = ack;
}

internal INPUT_STREAM_CALLBACK_DATA(on_input_stream_data)
{
	login_packet_handle(server, session, data, data_length);
}

// TODO(rhett): remove this later
internal INPUT_STREAM_CALLBACK_DATA(on_ping_input_stream_data)
{
	UNUSED(server);
	UNUSED(session);
	UNUSED(data);
	UNUSED(data_length);
};

internal OUTPUT_STREAM_CALLBACK_DATA(on_output_stream_data)
{
	App_State* app_state = server;
	Session_State* session_state = session;

	Core_Packet_Data packet =
	{
		.sequence = (u16)sequence,
		.data = data,
		.data_length = data_length,
	};

	if (!is_fragment)
	{
		core_packet_send(app_state->socket, app_state->platform_api, session_state->address.ip, session_state->address.port, &session_state->connection_args, Core_Packet_Kind_Data, &packet);
	}
	else
	{
		core_packet_send(app_state->socket, app_state->platform_api, session_state->address.ip, session_state->address.port, &session_state->connection_args, Core_Packet_Kind_Data_Fragment, &packet);
	}
}

#if 0
__declspec(dllexport) APP_INITIALIZE(server_initialize)
{
	App_State* app_state = app_memory->app_state;
	if (!app_state)
	{
		app_state = app_memory->app_state = arena_bootstrap_push_struct(app_memory->backing_memory.data,
		                                                                       app_memory->backing_memory.size,
		                                                                       "Total",
		                                                                       App_State,
		                                                                       arena_total);
		app_state->platform_api = &app_memory->platform_api;
		app_state->platform_state = &app_memory->platform_state;

		app_state->tick_ms = &app_memory->tick_ms;
		app_state->work_ms = &app_memory->work_ms;
		app_state->tick_count = &app_memory->tick_count;
		app_state->key_states = &app_memory->key_states;

#if defined(TERMINAL_UI)
		Buffer screen =
		{
			.size = sizeof(char) * SCREEN_RESOLUTION,
			.data = arena_push_size(&app_state->arena_total,
			                               screen.size),
		};
		app_state->screen = app_memory->screen = screen;
		//core_memory_fill(app_state->screen.data, ' ', app_state->screen.size);
#endif // TERMINAL_UI

		Buffer per_tick_backing_memory =
		{
			.size = MB(10),
			.data = arena_push_size(&app_state->arena_total,
			                               per_tick_backing_memory.size),
		};

		app_state->arena_per_tick =
			(Arena) {
			.buffer = per_tick_backing_memory.data,
			.capacity = per_tick_backing_memory.size,
			.name = "Tick",
		};

		u8 rc4_key_encoded[] = "F70IaxuU8C/w7FPXY1ibXw==";
		app_state->rc4_key_decoded_length = util_base64_decode((u8*)rc4_key_encoded,
		                                                       sizeof(rc4_key_encoded) - 1,
		                                                       app_state->rc4_key_decoded);

		app_state->connection_args.udp_length = MAX_PACKET_LENGTH;
		// TODO(rhett): encryption should probably be kept disabled initially and toggled on in higher layers
		//app_state->connection_args.use_encryption = FALSE;
		app_state->connection_args.should_dump_core = TRUE;
		app_state->connection_args.should_dump_login = TRUE;
		app_state->connection_args.should_dump_tunnel = TRUE;
		app_state->connection_args.should_dump_gateway = TRUE;
		app_state->connection_args.should_dump_zone = TRUE;
		
		app_state->sessions_capacity = MAX_SESSIONS_COUNT;
		app_state->socket = app_state->platform_api->socket_udp_create_and_bind(app_state->platform_state,
		                                                                        LOCAL_PORT);
		printf(MESSAGE_CONCAT_INFO("Login server socket bound to port " STRINGIFY(LOCAL_PORT) "\n\n"));
		app_state->platform_api->folder_create("packets");
	}
}
#endif

__declspec(dllexport) APP_TICK(server_tick)
{
	App_State* app_state = app_memory->app_state;
	if (!app_state)
	{
		app_state = app_memory->app_state = arena_bootstrap_push_struct(app_memory->backing_memory.data,
		                                                                app_memory->backing_memory.size,
		                                                                "Total",
		                                                                App_State,
		                                                                arena_total);
		app_state->platform_api = &app_memory->platform_api;
		app_state->tick_ms = &app_memory->tick_ms;
		app_state->work_ms = &app_memory->work_ms;
		app_state->tick_count = &app_memory->tick_count;
		app_state->key_states = &app_memory->key_states;

#if defined(TERMINAL_UI)
		Buffer screen =
		{
			.size = sizeof(char) * SCREEN_RESOLUTION,
			.data = arena_push_size(&app_state->arena_total,
			                        screen.size),
		};
		app_state->screen = app_memory->screen = screen;
		//core_memory_fill(app_state->screen.data, ' ', app_state->screen.size);
#endif // TERMINAL_UI

		Buffer per_tick_backing_memory =
		{
			.size = MB(10),
			.data = arena_push_size(&app_state->arena_total,
			                        per_tick_backing_memory.size),
		};

		app_state->stream_function_table = arena_push_struct(&app_state->arena_total, Stream_Function_Table);
		app_state->stream_function_table->login_input_ack = on_input_stream_ack;
		app_state->stream_function_table->login_input_data = on_input_stream_data;
		app_state->stream_function_table->login_output_data = on_output_stream_data;
		app_state->stream_function_table->ping_input_data = on_ping_input_stream_data;

		app_state->arena_per_tick =
			(Arena) {
			.buffer = per_tick_backing_memory.data,
			.capacity = per_tick_backing_memory.size,
			.name = "Tick",
		};

		u8 rc4_key_encoded[] = "F70IaxuU8C/w7FPXY1ibXw==";
		app_state->rc4_key_decoded_length = util_base64_decode((u8*)rc4_key_encoded,
		                                                       sizeof(rc4_key_encoded) - 1,
		                                                       app_state->rc4_key_decoded);

		app_state->connection_args.udp_length = MAX_PACKET_LENGTH;
		// TODO(rhett): encryption should probably be kept disabled initially and toggled on in higher layers
		//app_state->connection_args.use_encryption = FALSE;
		app_state->connection_args.should_dump_core = TRUE;
		app_state->connection_args.should_dump_login = TRUE;
		app_state->connection_args.should_dump_tunnel = TRUE;
		app_state->connection_args.should_dump_gateway = TRUE;
		app_state->connection_args.should_dump_zone = TRUE;
		
		app_state->sessions_capacity = MAX_SESSIONS_COUNT;
		app_state->socket = app_state->platform_api->socket_udp_create_and_bind(LOCAL_PORT);
		printf(MESSAGE_CONCAT_INFO("Login server socket bound to port " STRINGIFY(LOCAL_PORT) "\n\n"));
		app_state->platform_api->folder_create("packets");
	}

	if (should_reload)
	{
		printf(MESSAGE_CONCAT_INFO("Reloading function table...\n"));
		app_state->stream_function_table->login_input_ack = on_input_stream_ack;
		app_state->stream_function_table->login_input_data = on_input_stream_data;
		app_state->stream_function_table->login_output_data = on_output_stream_data;
		app_state->stream_function_table->ping_input_data = on_ping_input_stream_data;
	}

	global_tick_count = *app_state->tick_count;

#if defined(TERMINAL_UI)
	core_memory_fill(app_state->screen.data, ' ', app_state->screen.size);
	stbsp_sprintf((char*)app_state->screen.data,
	              "Tick: %llu    %fms/w | %fms/f", *app_state->tick_count, *app_state->work_ms, *app_state->tick_ms);

	i32 pos = 0;
	for (i32 key = 0; key < 0xff; key++)
	{
		pos += stbsp_sprintf((char*)(app_state->screen.data + (SCREEN_WIDTH * 2) + pos),
		                     "K%02x %s  ",
		                     key,
		                     toggle_state_text[(*app_state->key_states)[key]]);
	}

	//pos = SCREEN_WIDTH * 29;
	//pos += stbsp_sprintf((char*)(app_state->screen.data + pos),
	//"cool :)");
#endif // TERMINAL_UI

	u8 incoming_buffer[MAX_PACKET_LENGTH] = { 0 };
	u32 from_ip;
	u16 from_port;
	i32 receive_result = app_state->platform_api->receive_from(app_state->socket,
	                                                              incoming_buffer,
	                                                              MAX_PACKET_LENGTH,
	                                                              &from_ip,
	                                                              &from_port);
	if (receive_result)
	{
		printf("\n\nPacket Tick Begin ============================================================\\\\\n");

		Session_Address incoming_session_address =
		{
			.ip = from_ip,
			.port = from_port,
		};

		// TODO(rhett): will need cleaned up
		i32 first_free_session = -1;
		i32 known_session = -1;
		for (i32 i = 0; i < app_state->sessions_capacity; i++)
		{
			if (first_free_session == -1 && !app_state->sessions[i].address.full)
			{
				first_free_session = i;
			}

			if (known_session == -1 && incoming_session_address.full == app_state->sessions[i].address.full)
			{
				known_session = i;
			}

			if (first_free_session != -1 && known_session != -1)
			{
				break;
			}
		}

		if (core_packet_get_kind(incoming_buffer, receive_result) == Core_Packet_Kind_Session_Request)
		{
			if (known_session != -1)
			{
				printf(MESSAGE_CONCAT_INFO("Known client %u.%u.%u.%u:%u re-sent SessionRequest\n"),
				       (from_ip & 0xff000000) >> 24,
				       (from_ip & 0x00ff0000) >> 16,
				       (from_ip & 0x0000ff00) >> 8,
				       (from_ip & 0x000000ff),
				       from_port);
			}
			else
			{
				printf(MESSAGE_CONCAT_INFO("Unknown client %u.%u.%u.%u:%u sent SessionRequest. Beginning session\n"),
				       (from_ip & 0xff000000) >> 24,
				       (from_ip & 0x00ff0000) >> 16,
				       (from_ip & 0x0000ff00) >> 8,
				       (from_ip & 0x000000ff),
				       from_port);

				if (first_free_session == -1)
				{
					printf(MESSAGE_CONCAT_WARN("No free sessions avaliable\n"));
				}
				else
				{
					known_session = first_free_session;
					app_state->sessions[first_free_session].address.full = incoming_session_address.full;
					app_state->sessions[first_free_session].ack_next = -1;
					app_state->sessions[first_free_session].ack_previous = -1;

					base_memory_copy((void*)&app_state->sessions[first_free_session].connection_args,
					                 (void*)&app_state->connection_args,
					                 sizeof(app_state->connection_args));

					// TODO(rhett): These fragment pools will leak memory. this whole system needs refactored
					app_state->sessions[first_free_session].input_fragment_pool = fragment_pool_create(MAX_FRAGMENTS,
					                                                                                      MAX_PACKET_LENGTH,
					                                                                                      &app_state->arena_total);
					app_state->sessions[first_free_session].output_fragment_pool = fragment_pool_create(MAX_FRAGMENTS,
					                                                                                       MAX_PACKET_LENGTH - DATA_HEADER_LENGTH,
					                                                                                       &app_state->arena_total);
					app_state->sessions[first_free_session].input_stream = input_stream_init(&app_state->sessions[first_free_session].input_fragment_pool,
					                                                                            app_state->rc4_key_decoded,
					                                                                            app_state->rc4_key_decoded_length,
					                                                                            FALSE);
					app_state->sessions[first_free_session].output_stream = output_stream_init(&app_state->sessions[first_free_session].output_fragment_pool,
					                                                                              app_state->rc4_key_decoded,
					                                                                              app_state->rc4_key_decoded_length,
					                                                                              FALSE);
					app_state->sessions[first_free_session].input_stream.ack_callback_ptr = &app_state->stream_function_table->login_input_ack;
					app_state->sessions[first_free_session].input_stream.data_callback_ptr = &app_state->stream_function_table->login_input_data;
					app_state->sessions[first_free_session].output_stream.data_callback_ptr = &app_state->stream_function_table->login_output_data;
				}
			}
		}

		if (known_session != -1)
		{
			core_packet_handle(app_state,
			                   app_state->platform_api,
			                   &app_state->sessions[known_session],
			                   incoming_buffer,
			                   receive_result,
			                   FALSE);

			if (app_state->sessions[known_session].ack_previous != app_state->sessions[known_session].ack_next)
			{
				printf(MESSAGE_CONCAT_INFO("Syncing ack...\n"));
				app_state->sessions[known_session].ack_previous = app_state->sessions[known_session].ack_next;

				Ack ack =
				{
					.sequence = (u16)app_state->sessions[known_session].ack_next
				};

				core_packet_send(app_state->socket,
				                 app_state->platform_api,
				                 app_state->sessions[known_session].address.ip,
				                 app_state->sessions[known_session].address.port,
				                 &app_state->sessions[known_session].connection_args,
				                 Core_Packet_Kind_Ack,
				                 &ack);
			}
		}

		printf("Packet Tick End ==============================================================//\n");
	}

	// TODO(rhett): maybe double buffer
	arena_reset(&app_state->arena_per_tick);
}
#endif